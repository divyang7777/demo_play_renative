var _interopRequireDefault=require("@babel/runtime/helpers/interopRequireDefault");Object.defineProperty(exports,"__esModule",{value:true});exports.checkCrypto=exports.rnvCryptoUpdateProfiles=exports.rnvCryptoInstallCerts=exports.rnvCryptoInstallProfiles=exports.rnvCryptoDecrypt=exports.rnvCryptoEncrypt=exports.rnvCryptoUpdateProfile=void 0;var _regenerator=_interopRequireDefault(require("@babel/runtime/regenerator"));
var _path=_interopRequireDefault(require("path"));
var _tar=_interopRequireDefault(require("tar"));
var _chalk=_interopRequireDefault(require("chalk"));
var _util=require("util");
var _fs=_interopRequireDefault(require("fs"));
var _logger=require("./logger");







var _utils=require("../utils");
var _configParser=require("../configTools/configParser");



var _constants=require("../constants");
var _fileutils=require("./fileutils");









var _exec=require("./exec");
var _fastlane=require("../platformTools/apple/fastlane");
var _prompt=require("./prompt");

var iocane=require('iocane');

var readdirAsync=(0,_util.promisify)(_fs.default.readdir);

var getEnvVar=function getEnvVar(c){
var p1=c.paths.workspace.dir.
split('/').
pop().
replace('.','');
var p2=c.files.project.package.name.
replace('@','').
replace('/','_').
replace(/-/g,'_');
var envVar=("CRYPTO_"+p1+"_"+p2).toUpperCase();
(0,_logger.logDebug)('encrypt looking for env var:',envVar);
return envVar;
};

var rnvCryptoUpdateProfile=function rnvCryptoUpdateProfile(c){return _regenerator.default.async(function rnvCryptoUpdateProfile$(_context){while(1){switch(_context.prev=_context.next){case 0:_context.next=2;return _regenerator.default.awrap(
(0,_fastlane.updateProfile)(c));case 2:case"end":return _context.stop();}}},null,null,null,Promise);};exports.rnvCryptoUpdateProfile=rnvCryptoUpdateProfile;


var generateRandomKey=function generateRandomKey(length){return Array(length).
fill(
'0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz#$%^&*').

map(function(x){return x[Math.floor(Math.random()*x.length)];}).
join('');};

var _getEnvExportCmd=function _getEnvExportCmd(envVar,key){
if(_utils.isSystemWin){
return""+_chalk.default.white("setx "+envVar+" \""+key+"\"");
}
return""+_chalk.default.white("export "+envVar+"=\""+key+"\"");
};

var _checkAndConfigureCrypto=function _checkAndConfigureCrypto(c){var source,_await$inquirerPrompt,location,sourceFolder,configDirs,_await$inquirerPrompt2,confirm,envVar,key,keyGenerated,_await$inquirerPrompt3,_confirm;return _regenerator.default.async(function _checkAndConfigureCrypto$(_context2){while(1){switch(_context2.prev=_context2.next){case 0:

source="./"+c.files.project.package.name;if(!(

c.files.project.config&&!c.files.project.config.crypto)){_context2.next=8;break;}_context2.next=4;return _regenerator.default.awrap(
(0,_prompt.inquirerPrompt)({
type:'input',
name:'location',
message:
'Where would you like your secrets to be residing? (path relative to root, without leading or trailing slash. Ex. `myPrivateConfig/encrypt`)',
default:'secrets'}));case 4:_await$inquirerPrompt=_context2.sent;location=_await$inquirerPrompt.location;

c.files.project.config.crypto={
encrypt:{
dest:"PROJECT_HOME/"+location+"/privateConfigs.enc"},

decrypt:{
source:"PROJECT_HOME/"+location+"/privateConfigs.enc"}};


(0,_fileutils.writeFileSync)(c.paths.project.config,c.files.project.config);case 8:



sourceFolder=_path.default.join(c.paths.workspace.dir,source);if(
_fs.default.existsSync(sourceFolder)){_context2.next=24;break;}
(0,_logger.logInfo)("It seems you are running encrypt for the first time. Directory "+
_chalk.default.white(
sourceFolder)+" does not exist yet.\nRNV will create it for you, make sure you add whatever you want encrypted in it and then run the command again");




(0,_fileutils.mkdirSync)(sourceFolder);
(0,_fileutils.mkdirSync)(_path.default.join(sourceFolder,'certs'));
(0,_fileutils.writeFileSync)(_path.default.join(sourceFolder,'renative.private.json'),{});_context2.next=16;return _regenerator.default.awrap(

readdirAsync(c.paths.project.appConfigsDir));case 16:configDirs=_context2.sent;

configDirs.forEach(function(item){
var appConfigDir=_path.default.join(sourceFolder,item);
(0,_fileutils.mkdirSync)(appConfigDir);
(0,_fileutils.mkdirSync)(_path.default.join(appConfigDir,'certs'));
(0,_fileutils.writeFileSync)(_path.default.join(appConfigDir,'renative.private.json'),{});
});_context2.next=20;return _regenerator.default.awrap(


(0,_prompt.inquirerPrompt)({
type:'confirm',
message:'Once ready, Continue?'}));case 20:_await$inquirerPrompt2=_context2.sent;confirm=_await$inquirerPrompt2.confirm;if(!


confirm){_context2.next=24;break;}return _context2.abrupt("return",true);case 24:


envVar=getEnvVar(c);
key=c.program.key||c.process.env[envVar];
keyGenerated=false;if(
key){_context2.next=39;break;}_context2.next=30;return _regenerator.default.awrap(
(0,_prompt.inquirerPrompt)({
type:'confirm',
message:"You haven't passed a key with --key or set an env variable named "+_chalk.default.yellow(
envVar)+" for the encryption key. Would you like to generate one?"}));case 30:_await$inquirerPrompt3=_context2.sent;_confirm=_await$inquirerPrompt3.confirm;if(!


_confirm){_context2.next=37;break;}
key=generateRandomKey(20);
keyGenerated=true;_context2.next=38;break;case 37:return _context2.abrupt("return",

Promise.reject("encrypt: You must pass "+_chalk.default.white(
'--key')+" or have env var defined:\n\n"+


_getEnvExportCmd(envVar,'REPLACE_WITH_ENV_VARIABLE')+"\n\n"));case 38:



if(keyGenerated){
(0,_logger.logSuccess)("The files were encrypted with key "+_chalk.default.red(
key)+". Make sure you keep it safe! Pass it with --key on decryption or set it as following env variable:\n\n"+


_getEnvExportCmd(envVar,key)+"\n\n");


c.process.env[envVar]=key;
}case 39:case"end":return _context2.stop();}}},null,null,null,Promise);};



var rnvCryptoEncrypt=function rnvCryptoEncrypt(c){var _c$files$project$conf,_c$files$project$conf2,_c$files$project$conf3;var source,destRaw,tsWorkspacePath,envVar,key,dest,destTemp,timestamp,destFolder,data;return _regenerator.default.async(function rnvCryptoEncrypt$(_context3){while(1){switch(_context3.prev=_context3.next){case 0:
(0,_logger.logTask)('rnvCryptoEncrypt');

source="./"+c.files.project.package.name;_context3.next=4;return _regenerator.default.awrap(

_checkAndConfigureCrypto(c));case 4:

destRaw=(_c$files$project$conf=c.files.project.config)==null?void 0:(_c$files$project$conf2=_c$files$project$conf.crypto)==null?void 0:(_c$files$project$conf3=_c$files$project$conf2.encrypt)==null?void 0:_c$files$project$conf3.dest;
tsWorkspacePath=_path.default.join(
c.paths.workspace.dir,
c.files.project.package.name,
'timestamp');

envVar=getEnvVar(c);
key=c.program.key||c.process.env[envVar];if(!

destRaw){_context3.next=26;break;}
dest=""+(0,_fileutils.getRealPath)(c,destRaw,'encrypt.dest');
destTemp=_path.default.join(
c.paths.workspace.dir,
c.files.project.package.name.replace('/','-'))+".tgz";

timestamp=new Date().getTime();


destFolder=_path.default.join(dest,'../');
!_fs.default.existsSync(destFolder)&&(0,_fileutils.mkdirSync)(destFolder);_context3.next=16;return _regenerator.default.awrap(

_tar.default.c(
{
gzip:true,
file:destTemp,
cwd:c.paths.workspace.dir},

[source]));case 16:_context3.next=18;return _regenerator.default.awrap(



iocane.createSession().
use('cbc').
encrypt(_fs.default.readFileSync(destTemp),key));case 18:data=_context3.sent;

(0,_fileutils.fsWriteFileSync)(dest,data);








(0,_fileutils.removeFilesSync)([destTemp]);
(0,_fileutils.fsWriteFileSync)(dest+".timestamp",timestamp);
(0,_fileutils.fsWriteFileSync)(""+tsWorkspacePath,timestamp);
(0,_logger.logSuccess)("Files succesfully encrypted into "+dest);_context3.next=27;break;case 26:

(0,_logger.logWarning)("You don't have {{ crypto.encrypt.dest }} specificed in "+
_chalk.default.white(
c.paths.projectConfig));case 27:case"end":return _context3.stop();}}},null,null,null,Promise);};exports.rnvCryptoEncrypt=rnvCryptoEncrypt;





var _unzipAndCopy=function _unzipAndCopy(
c,
shouldCleanFolder,
destTemp,
wsPath,
ts,
destFolder){return _regenerator.default.async(function _unzipAndCopy$(_context4){while(1){switch(_context4.prev=_context4.next){case 0:if(!

shouldCleanFolder){_context4.next=3;break;}_context4.next=3;return _regenerator.default.awrap(
(0,_fileutils.cleanFolder)(wsPath));case 3:_context4.next=5;return _regenerator.default.awrap(


_tar.default.x({
file:destTemp,
cwd:c.paths.workspace.dir}));case 5:


(0,_fileutils.removeFilesSync)([destTemp]);
if(_fs.default.existsSync(ts)){
(0,_fileutils.copyFileSync)(
ts,
_path.default.join(
c.paths.workspace.dir,
c.files.project.package.name,
'timestamp'));


}
(0,_logger.logSuccess)("Files succesfully extracted into "+destFolder);case 8:case"end":return _context4.stop();}}},null,null,null,Promise);};


var rnvCryptoDecrypt=function rnvCryptoDecrypt(c){var _c$files$project$conf4,_c$files$project$conf5,_c$files$project$conf6;var sourceRaw,source,ts,destFolder,destTemp,envVar,shouldCleanFolder,wsPath,isCryptoReset,options,_await$inquirerPrompt4,option,_await$inquirerPrompt5,confirm,key,data,_e$message,err;return _regenerator.default.async(function rnvCryptoDecrypt$(_context5){while(1){switch(_context5.prev=_context5.next){case 0:
(0,_logger.logTask)('rnvCryptoDecrypt');

sourceRaw=(_c$files$project$conf4=c.files.project.config)==null?void 0:(_c$files$project$conf5=_c$files$project$conf4.crypto)==null?void 0:(_c$files$project$conf6=_c$files$project$conf5.decrypt)==null?void 0:_c$files$project$conf6.source;if(!

sourceRaw){_context5.next=60;break;}
source=""+(0,_fileutils.getRealPath)(c,sourceRaw,'decrypt.source');
ts=source+".timestamp";
destFolder=_path.default.join(
c.paths.workspace.dir,
c.files.project.package.name);

destTemp=_path.default.join(
c.paths.workspace.dir,
c.files.project.package.name.replace('/','-'))+".tgz";

envVar=getEnvVar(c);
shouldCleanFolder=false;
wsPath=_path.default.join(
c.paths.workspace.dir,
c.files.project.package.name);

isCryptoReset=c.command==='crypto'&&c.program.reset===true;if(!(

c.program.ci!==true&&!isCryptoReset)){_context5.next=25;break;}
options=[
'Yes - override (recommended)',
'Yes - merge',
'Skip'];_context5.next=15;return _regenerator.default.awrap(

(0,_prompt.inquirerPrompt)({
name:'option',
type:'list',
choices:options,
message:"How to decrypt to "+_chalk.default.white(destFolder)+" ?"}));case 15:_await$inquirerPrompt4=_context5.sent;option=_await$inquirerPrompt4.option;if(!(

option===options[0])){_context5.next=21;break;}
shouldCleanFolder=true;_context5.next=23;break;case 21:if(!(
option===options[2])){_context5.next=23;break;}return _context5.abrupt("return",
true);case 23:_context5.next=26;break;case 25:


shouldCleanFolder=true;case 26:if(!


_fs.default.existsSync(destTemp)){_context5.next=35;break;}_context5.next=29;return _regenerator.default.awrap(
(0,_prompt.inquirerPrompt)({
type:'confirm',
message:"Found existing decrypted file at "+_chalk.default.white(
destTemp)+". want to use it and skip decrypt ?"}));case 29:_await$inquirerPrompt5=_context5.sent;confirm=_await$inquirerPrompt5.confirm;if(!


confirm){_context5.next=35;break;}_context5.next=34;return _regenerator.default.awrap(
_unzipAndCopy(
c,
shouldCleanFolder,
destTemp,
wsPath,
ts,
destFolder));case 34:return _context5.abrupt("return",

true);case 35:



key=c.program.key||c.process.env[envVar];if(
key){_context5.next=38;break;}return _context5.abrupt("return",
Promise.reject("encrypt: You must pass "+_chalk.default.white(
'--key')+" or have env var defined:\n\n"+


_getEnvExportCmd(envVar,'REPLACE_WITH_ENV_VARIABLE')+"\n\n"));case 38:if(



_fs.default.existsSync(source)){_context5.next=40;break;}return _context5.abrupt("return",
Promise.reject("Can't decrypt. "+
_chalk.default.white(source)+" is missing!"));case 40:_context5.prev=40;_context5.next=43;return _regenerator.default.awrap(





iocane.createSession().
use('cbc').
decrypt(_fs.default.readFileSync(source),key));case 43:data=_context5.sent;_context5.next=55;break;case 46:_context5.prev=46;_context5.t0=_context5["catch"](40);if(!(_context5.t0==null?void 0:(_e$message=

_context5.t0.message)==null?void 0:_e$message.includes)){_context5.next=54;break;}if(!
_context5.t0.message.includes('Signature mismatch')){_context5.next=52;break;}
err="Looks like you're trying to decode crypto file encoded with previous version of crypto.\nthis change was introduced in \"rnv@0.29.0\"\n\n"+_context5.t0+"\n\n      "+




_chalk.default.green('SUGGESTION:')+"\n\n      "+

_chalk.default.yellow('STEP 1:')+"\n      run: "+
_chalk.default.white('rnv crypto encrypt')+" locally at least once and commit the result back to your repository\n\n      "+

_chalk.default.yellow('STEP 2:')+"\n      you should be able to use: "+
_chalk.default.white('rnv crypto decrypt')+" properly now\n\n      "+

_chalk.default.yellow('IF ALL HOPE IS LOST:')+"\n      Raise new issue and copy this SUMMARY box output at:\n      "+

_chalk.default.white('https://github.com/pavjacko/renative/issues')+"\n      and we will try to help!\n\n      ";return _context5.abrupt("return",




Promise.reject(err));case 52:if(!
_context5.t0.message.includes('Authentication failed')){_context5.next=54;break;}return _context5.abrupt("return",
Promise.reject("It seems like you provided invalid decryption key.\n\n"+

_context5.t0.stack+"\n\n"+

_chalk.default.green('SUGGESTION:')+"\n\n"+

_chalk.default.yellow('STEP 1:')+"\ncheck if your ENV VAR is correct: "+
_getEnvExportCmd(envVar,'***********')+"\nor if someone did not encrypt "+
_chalk.default.white(source)+" with a different key\n\n"+

_chalk.default.yellow('STEP 2:')+"\nrun crypto decrypt again\n\n"+


_chalk.default.yellow('IF ALL HOPE IS LOST:')+"\nRaise new issue and copy this SUMMARY box output at:\n"+

_chalk.default.white('https://github.com/pavjacko/renative/issues')+"\nand we will try to help!\n\n"));case 54:return _context5.abrupt("return",






Promise.reject(_context5.t0));case 55:



(0,_fileutils.fsWriteFileSync)(destTemp,data);_context5.next=58;return _regenerator.default.awrap(


























_unzipAndCopy(
c,
shouldCleanFolder,
destTemp,
wsPath,
ts,
destFolder));case 58:_context5.next=62;break;case 60:


(0,_logger.logWarning)("You don't have {{ crypto.encrypt.dest }} specificed in "+
_chalk.default.white(
c.paths.projectConfig));return _context5.abrupt("return",


true);case 62:case"end":return _context5.stop();}}},null,null,[[40,46]],Promise);};exports.rnvCryptoDecrypt=rnvCryptoDecrypt;


















var rnvCryptoInstallProfiles=function rnvCryptoInstallProfiles(c){return new Promise(function(resolve){
(0,_logger.logTask)('rnvCryptoInstallProfiles');
if(c.platform!=='ios'){
(0,_logger.logError)("rnvCryptoInstallProfiles: platform "+
c.platform+" not supported");

resolve();
return;
}

var ppFolder=_path.default.join(
c.paths.home.dir,
'Library/MobileDevice/Provisioning Profiles');


if(!_fs.default.existsSync(ppFolder)){
(0,_logger.logWarning)("folder "+ppFolder+" does not exist!");
(0,_fileutils.mkdirSync)(ppFolder);
}

var list=(0,_fileutils.getFileListSync)(c.paths.workspace.project.dir);
var mobileprovisionArr=list.filter(function(v){return v.endsWith('.mobileprovision');});

try{
mobileprovisionArr.forEach(function(v){
(0,_logger.logDebug)("rnvCryptoInstallProfiles: Installing: "+v);
(0,_fileutils.copyFileSync)(v,ppFolder);
});
}catch(e){
(0,_logger.logError)(e);
}

resolve();
});};exports.rnvCryptoInstallProfiles=rnvCryptoInstallProfiles;

var rnvCryptoInstallCerts=function rnvCryptoInstallCerts(c){return new Promise(function(resolve){
(0,_logger.logTask)('rnvCryptoInstallCerts');

if(c.platform!=='ios'){
(0,_logger.logError)("_installTempCerts: platform "+c.platform+" not supported");
resolve();
return;
}
var kChain=c.program.keychain||'ios-build.keychain';

var list=(0,_fileutils.getFileListSync)(c.paths.workspace.project.dir);
var cerArr=list.filter(function(v){return v.endsWith('.cer');});

Promise.all(
cerArr.map(function(v){return(0,_exec.executeAsync)(c,"security import "+v+" -k "+kChain+" -A");})).

then(function(){return resolve();}).
catch(function(e){
(0,_logger.logWarning)(e);
resolve();
});
});};exports.rnvCryptoInstallCerts=rnvCryptoInstallCerts;

var rnvCryptoUpdateProfiles=function rnvCryptoUpdateProfiles(c){var _c$runtime;return _regenerator.default.async(function rnvCryptoUpdateProfiles$(_context6){while(1){switch(_context6.prev=_context6.next){case 0:
(0,_logger.logTask)('rnvCryptoUpdateProfiles');_context6.t0=
c.platform;_context6.next=_context6.t0===
_constants.IOS?4:_context6.t0===
_constants.TVOS?4:9;break;case 4:_context6.next=6;return _regenerator.default.awrap(
_updateProfiles(c));case 6:_context6.next=8;return _regenerator.default.awrap(
(0,_configParser.setAppConfig)(c,(_c$runtime=c.runtime)==null?void 0:_c$runtime.appId));case 8:return _context6.abrupt("break",10);case 9:return _context6.abrupt("return",


true);case 10:return _context6.abrupt("return",

Promise.reject("updateProfiles: Platform "+
c.platform+" not supported"));case 11:case"end":return _context6.stop();}}},null,null,null,Promise);};exports.rnvCryptoUpdateProfiles=rnvCryptoUpdateProfiles;



var _updateProfiles=function _updateProfiles(c){
(0,_logger.logTask)('_updateProfiles',_chalk.default.grey);
var acList=(0,_configParser.listAppConfigsFoldersSync)(c,true);

return acList.reduce(
function(previousPromise,v){return previousPromise.then(function(){return _updateProfile(c,v);});},
Promise.resolve());

};

var _updateProfile=function _updateProfile(c,v){return new Promise(function(resolve,reject){
(0,_logger.logTask)("_updateProfile:"+v,_chalk.default.grey);
(0,_fastlane.updateProfile)(c,v).
then(function(){return resolve();}).
catch(function(e){return reject(e);});
});};

var checkCrypto=function checkCrypto(c){var _c$files$project$conf7,_c$files$project$conf8,_c$files$project$conf9,_c$files$project$conf10,_c$files$project$conf11,_c$files$project$conf12;var sourceRaw,destRaw,source,tsProjectPath,wsPath,tsWorkspacePath,tsWorkspace,tsProject;return _regenerator.default.async(function checkCrypto$(_context7){while(1){switch(_context7.prev=_context7.next){case 0:
(0,_logger.logTask)('checkCrypto');if(!

c.program.ci){_context7.next=3;break;}return _context7.abrupt("return");case 3:

sourceRaw=(_c$files$project$conf7=c.files.project.config)==null?void 0:(_c$files$project$conf8=_c$files$project$conf7.crypto)==null?void 0:(_c$files$project$conf9=_c$files$project$conf8.decrypt)==null?void 0:_c$files$project$conf9.source;
destRaw=(_c$files$project$conf10=c.files.project.config)==null?void 0:(_c$files$project$conf11=_c$files$project$conf10.crypto)==null?void 0:(_c$files$project$conf12=_c$files$project$conf11.encrypt)==null?void 0:_c$files$project$conf12.dest;if(!

destRaw){_context7.next=25;break;}if(!(
sourceRaw&&destRaw)){_context7.next=25;break;}
source=""+(0,_fileutils.getRealPath)(c,sourceRaw,'decrypt.source');
tsProjectPath=source+".timestamp";
wsPath=_path.default.join(
c.paths.workspace.dir,
c.files.project.package.name);

tsWorkspacePath=_path.default.join(wsPath,'timestamp');if(
_fs.default.existsSync(source)){_context7.next=15;break;}
(0,_logger.logWarning)(
"This project uses encrypted files but you don't have them installed");_context7.next=25;break;case 15:


tsWorkspace=0;
tsProject=0;
if(_fs.default.existsSync(tsWorkspacePath)){
tsWorkspace=parseInt(
_fs.default.readFileSync(tsWorkspacePath).toString(),
10);

}

if(_fs.default.existsSync(tsProjectPath)){
tsProject=parseInt(
_fs.default.readFileSync(tsProjectPath).toString(),
10);

}if(!(

tsProject>tsWorkspace)){_context7.next=24;break;}
(0,_logger.logWarning)("Your "+tsWorkspacePath+" is out of date.\nproject timestamp: "+
_chalk.default.grey(tsProject+" - "+new Date(tsProject))+"\nworkspace timestamp: "+
_chalk.default.grey(tsWorkspace+" - "+new Date(tsWorkspace))+"\nyou should run decrypt");_context7.next=23;return _regenerator.default.awrap(

rnvCryptoDecrypt(c));case 23:return _context7.abrupt("return");case 24:



if(tsProject<tsWorkspace){
(0,_logger.logWarning)("Your "+
tsWorkspacePath+" is newer than your project one.");

}case 25:case"end":return _context7.stop();}}},null,null,null,Promise);};exports.checkCrypto=checkCrypto;
//# sourceMappingURL=crypto.js.map