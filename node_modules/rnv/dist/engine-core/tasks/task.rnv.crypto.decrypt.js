var _interopRequireDefault=require("@babel/runtime/helpers/interopRequireDefault");Object.defineProperty(exports,"__esModule",{value:true});exports.default=exports.taskRnvCryptoDecrypt=void 0;var _regenerator=_interopRequireDefault(require("@babel/runtime/regenerator"));var _path=_interopRequireDefault(require("path"));
var _tar=_interopRequireDefault(require("tar"));
var _logger=require("../../core/systemManager/logger");





var _fileutils=require("../../core/systemManager/fileutils");








var _prompt=require("../../cli/prompt");
var _crypto=require("../../core/systemManager/crypto");
var _engineManager=require("../../core/engineManager");
var _constants=require("../../core/constants");


var iocane=require('iocane');

var _unzipAndCopy=function _unzipAndCopy(
c,
shouldCleanFolder,
destTemp,
wsPath,
ts,
destFolder){return _regenerator.default.async(function _unzipAndCopy$(_context){while(1){switch(_context.prev=_context.next){case 0:if(!

shouldCleanFolder){_context.next=3;break;}_context.next=3;return _regenerator.default.awrap(
(0,_fileutils.cleanFolder)(wsPath));case 3:_context.next=5;return _regenerator.default.awrap(


_tar.default.x({
file:destTemp,
cwd:c.paths.workspace.dir}));case 5:


(0,_fileutils.removeFilesSync)([destTemp]);
if((0,_fileutils.fsExistsSync)(ts)){
(0,_fileutils.copyFileSync)(
ts,
_path.default.join(
c.paths.workspace.dir,
c.files.project.package.name,
'timestamp'));


}
(0,_logger.logSuccess)("Files succesfully extracted into "+destFolder);case 8:case"end":return _context.stop();}}},null,null,null,Promise);};


var taskRnvCryptoDecrypt=function taskRnvCryptoDecrypt(c,parentTask,originTask){var _c$files$project$conf,_c$files$project$conf2,_c$files$project$conf3;var sourceRaw,source,ts,destFolder,destTemp,envVar,shouldCleanFolder,wsPath,isCryptoReset,options,_await$inquirerPrompt,option,_await$inquirerPrompt2,confirm,key,data,_e$message,err;return _regenerator.default.async(function taskRnvCryptoDecrypt$(_context2){while(1){switch(_context2.prev=_context2.next){case 0:
(0,_logger.logTask)('taskRnvCryptoDecrypt');if(

parentTask){_context2.next=4;break;}_context2.next=4;return _regenerator.default.awrap(
(0,_engineManager.executeTask)(c,_constants.TASK_PROJECT_CONFIGURE,_constants.TASK_CRYPTO_DECRYPT,originTask));case 4:


sourceRaw=(_c$files$project$conf=c.files.project.config)==null?void 0:(_c$files$project$conf2=_c$files$project$conf.crypto)==null?void 0:(_c$files$project$conf3=_c$files$project$conf2.decrypt)==null?void 0:_c$files$project$conf3.source;if(!

sourceRaw){_context2.next=63;break;}
source=""+(0,_fileutils.getRealPath)(c,sourceRaw,'decrypt.source');
ts=source+".timestamp";
destFolder=_path.default.join(
c.paths.workspace.dir,
c.files.project.package.name);

destTemp=_path.default.join(
c.paths.workspace.dir,
c.files.project.package.name.replace('/','-'))+".tgz";

envVar=(0,_crypto.getEnvVar)(c);
shouldCleanFolder=false;
wsPath=_path.default.join(
c.paths.workspace.dir,
c.files.project.package.name);

isCryptoReset=c.command==='crypto'&&c.program.reset===true;if(!(

c.program.ci!==true&&!isCryptoReset)){_context2.next=28;break;}
options=[
'Yes - override (recommended)',
'Yes - merge',
'Skip'];_context2.next=18;return _regenerator.default.awrap(

(0,_prompt.inquirerPrompt)({
name:'option',
type:'list',
choices:options,
message:"How to decrypt to "+(0,_logger.chalk)().white(destFolder)+" ?"}));case 18:_await$inquirerPrompt=_context2.sent;option=_await$inquirerPrompt.option;if(!(

option===options[0])){_context2.next=24;break;}
shouldCleanFolder=true;_context2.next=26;break;case 24:if(!(
option===options[2])){_context2.next=26;break;}return _context2.abrupt("return",
true);case 26:_context2.next=29;break;case 28:


shouldCleanFolder=true;case 29:if(!


(0,_fileutils.fsExistsSync)(destTemp)){_context2.next=38;break;}_context2.next=32;return _regenerator.default.awrap(
(0,_prompt.inquirerPrompt)({
type:'confirm',
message:"Found existing decrypted file at "+(0,_logger.chalk)().white(
destTemp)+". want to use it and skip decrypt ?"}));case 32:_await$inquirerPrompt2=_context2.sent;confirm=_await$inquirerPrompt2.confirm;if(!


confirm){_context2.next=38;break;}_context2.next=37;return _regenerator.default.awrap(
_unzipAndCopy(
c,
shouldCleanFolder,
destTemp,
wsPath,
ts,
destFolder));case 37:return _context2.abrupt("return",

true);case 38:



key=c.program.key||c.process.env[envVar];if(
key){_context2.next=41;break;}return _context2.abrupt("return",
Promise.reject("encrypt: You must pass "+(0,_logger.chalk)().white(
'--key')+" or have env var defined:\n\n"+


(0,_crypto.getEnvExportCmd)(envVar,'REPLACE_WITH_ENV_VARIABLE')+"\n\n"));case 41:if(



(0,_fileutils.fsExistsSync)(source)){_context2.next=43;break;}return _context2.abrupt("return",
Promise.reject("Can't decrypt. "+
(0,_logger.chalk)().white(source)+" is missing!"));case 43:_context2.prev=43;_context2.next=46;return _regenerator.default.awrap(





iocane.createSession().
use('cbc').
decrypt((0,_fileutils.fsReadFileSync)(source),key));case 46:data=_context2.sent;_context2.next=58;break;case 49:_context2.prev=49;_context2.t0=_context2["catch"](43);if(!(_context2.t0==null?void 0:(_e$message=

_context2.t0.message)==null?void 0:_e$message.includes)){_context2.next=57;break;}if(!
_context2.t0.message.includes('Signature mismatch')){_context2.next=55;break;}
err="You're trying to decode crypto file encoded with previous version of crypto.\nthis change was introduced in \"rnv@0.29.0\"\n\n"+_context2.t0+"\n\n      "+




(0,_logger.chalk)().green('SUGGESTION:')+"\n\n      "+

(0,_logger.chalk)().yellow('STEP 1:')+"\n      run: "+
(0,_logger.chalk)().white('rnv crypto encrypt')+" locally at least once and commit the result back to your repository\n\n      "+

(0,_logger.chalk)().yellow('STEP 2:')+"\n      you should be able to use: "+
(0,_logger.chalk)().white('rnv crypto decrypt')+" properly now\n\n      "+

(0,_logger.chalk)().yellow('IF ALL HOPE IS LOST:')+"\n      Raise new issue and copy this SUMMARY box output at:\n      "+

(0,_logger.chalk)().white('https://github.com/pavjacko/renative/issues')+"\n      and we will try to help!\n\n      ";return _context2.abrupt("return",




Promise.reject(err));case 55:if(!
_context2.t0.message.includes('Authentication failed')){_context2.next=57;break;}return _context2.abrupt("return",
Promise.reject("It seems like you provided invalid decryption key.\n\n"+

_context2.t0.stack+"\n\n"+

(0,_logger.chalk)().green('SUGGESTION:')+"\n\n"+

(0,_logger.chalk)().yellow('STEP 1:')+"\ncheck if your ENV VAR is correct: "+
(0,_crypto.getEnvExportCmd)(envVar,'***********')+"\nor if someone did not encrypt "+
(0,_logger.chalk)().white(source)+" with a different key\n\n"+

(0,_logger.chalk)().yellow('STEP 2:')+"\nrun crypto decrypt again\n\n"+


(0,_logger.chalk)().yellow('IF ALL HOPE IS LOST:')+"\nRaise new issue and copy this SUMMARY box output at:\n"+

(0,_logger.chalk)().white('https://github.com/pavjacko/renative/issues')+"\nand we will try to help!\n\n"));case 57:return _context2.abrupt("return",






Promise.reject(_context2.t0));case 58:



(0,_fileutils.fsWriteFileSync)(destTemp,data);_context2.next=61;return _regenerator.default.awrap(


























_unzipAndCopy(
c,
shouldCleanFolder,
destTemp,
wsPath,
ts,
destFolder));case 61:_context2.next=65;break;case 63:


(0,_logger.logWarning)("You don't have {{ crypto.encrypt.dest }} specificed in "+
(0,_logger.chalk)().white(
c.paths.appConfigBase));return _context2.abrupt("return",


true);case 65:case"end":return _context2.stop();}}},null,null,[[43,49]],Promise);};exports.taskRnvCryptoDecrypt=taskRnvCryptoDecrypt;var _default=



{
description:'Decrypt encrypted project files into local ~/<wokspace>/<project>/..',
fn:taskRnvCryptoDecrypt,
task:_constants.TASK_CRYPTO_DECRYPT,
params:_constants.PARAMS.withBase(),
platforms:[],
skipPlatforms:true};exports.default=_default;
//# sourceMappingURL=task.rnv.crypto.decrypt.js.map