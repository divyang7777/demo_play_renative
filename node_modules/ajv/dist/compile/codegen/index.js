"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.or = exports.and = exports.CodeGen = exports.varKinds = exports.operators = exports.ValueScope = exports.Scope = exports.Name = exports.stringify = exports.getProperty = exports.nil = exports.strConcat = exports.str = exports._ = void 0;
const code_1 = require("./code");
const scope_1 = require("./scope");
var code_2 = require("./code");
Object.defineProperty(exports, "_", { enumerable: true, get: function () { return code_2._; } });
Object.defineProperty(exports, "str", { enumerable: true, get: function () { return code_2.str; } });
Object.defineProperty(exports, "strConcat", { enumerable: true, get: function () { return code_2.strConcat; } });
Object.defineProperty(exports, "nil", { enumerable: true, get: function () { return code_2.nil; } });
Object.defineProperty(exports, "getProperty", { enumerable: true, get: function () { return code_2.getProperty; } });
Object.defineProperty(exports, "stringify", { enumerable: true, get: function () { return code_2.stringify; } });
Object.defineProperty(exports, "Name", { enumerable: true, get: function () { return code_2.Name; } });
var scope_2 = require("./scope");
Object.defineProperty(exports, "Scope", { enumerable: true, get: function () { return scope_2.Scope; } });
Object.defineProperty(exports, "ValueScope", { enumerable: true, get: function () { return scope_2.ValueScope; } });
var BlockKind;
(function (BlockKind) {
    BlockKind[BlockKind["If"] = 0] = "If";
    BlockKind[BlockKind["Else"] = 1] = "Else";
    BlockKind[BlockKind["For"] = 2] = "For";
    BlockKind[BlockKind["Func"] = 3] = "Func";
})(BlockKind || (BlockKind = {}));
exports.operators = {
    GT: new code_1._Code(">"),
    GTE: new code_1._Code(">="),
    LT: new code_1._Code("<"),
    LTE: new code_1._Code("<="),
    EQ: new code_1._Code("==="),
    NEQ: new code_1._Code("!=="),
    NOT: new code_1._Code("!"),
    OR: new code_1._Code("||"),
    AND: new code_1._Code("&&"),
};
exports.varKinds = {
    const: new code_1.Name("const"),
    let: new code_1.Name("let"),
    var: new code_1.Name("var"),
};
class CodeGen {
    constructor(extScope, opts = {}) {
        this._values = {};
        this._blocks = [];
        this._blockStarts = [];
        this._out = "";
        this.opts = opts;
        this._extScope = extScope;
        this._scope = new scope_1.Scope({ parent: extScope });
        this._n = opts.lines ? "\n" : "";
    }
    toString() {
        return this._out;
    }
    // returns unique name in the internal scope
    name(prefix) {
        return this._scope.name(prefix);
    }
    // reserves unique name in the external scope
    scopeName(prefix) {
        return this._extScope.name(prefix);
    }
    // reserves unique name in the external scope and assigns value to it
    scopeValue(prefixOrName, value) {
        const name = this._extScope.value(prefixOrName, value);
        const vs = this._values[name.prefix] || (this._values[name.prefix] = new Set());
        vs.add(name);
        return name;
    }
    getScopeValue(prefix, keyOrRef) {
        return this._extScope.getValue(prefix, keyOrRef);
    }
    // return code that assigns values in the external scope to the names that are used internally
    // (same names that were returned by gen.scopeName or gen.scopeValue)
    scopeRefs(scopeName) {
        return this._extScope.scopeRefs(scopeName, this._values);
    }
    _def(varKind, nameOrPrefix, rhs) {
        const name = this._scope.toName(nameOrPrefix);
        if (this.opts.es5)
            varKind = exports.varKinds.var;
        if (rhs === undefined)
            this._out += `${varKind} ${name};` + this._n;
        else
            this._out += `${varKind} ${name} = ${rhs};` + this._n;
        return name;
    }
    // render `const` declaration (`var` in es5 mode)
    const(nameOrPrefix, rhs) {
        return this._def(exports.varKinds.const, nameOrPrefix, rhs);
    }
    // render `let` declaration with optional assignment (`var` in es5 mode)
    let(nameOrPrefix, rhs) {
        return this._def(exports.varKinds.let, nameOrPrefix, rhs);
    }
    // render `var` declaration with optional assignment
    var(nameOrPrefix, rhs) {
        return this._def(exports.varKinds.var, nameOrPrefix, rhs);
    }
    // render assignment
    assign(name, rhs) {
        this._out += `${name} = ${rhs};` + this._n;
        return this;
    }
    // appends passed SafeExpr to code or executes Block
    code(c) {
        if (typeof c == "function")
            c();
        else
            this._out += `${c};${this._n}`;
        return this;
    }
    // returns code for object literal for the passed argument list of key-value pairs
    object(...keyValues) {
        const values = keyValues
            .map(([key, value]) => (key === value && !this.opts.es5 ? key : `${key}:${value}`))
            .reduce((c1, c2) => `${c1},${c2}`);
        return new code_1._Code(`{${values}}`);
    }
    // render `if` clause (or statement if `thenBody` and, optionally, `elseBody` are passed)
    if(condition, thenBody, elseBody) {
        this._blocks.push(BlockKind.If);
        this._out += `if(${condition}){` + this._n;
        if (thenBody && elseBody) {
            this.code(thenBody).else().code(elseBody).endIf();
        }
        else if (thenBody) {
            this.code(thenBody).endIf();
        }
        else if (elseBody) {
            throw new Error('CodeGen: "else" body without "then" body');
        }
        return this;
    }
    // render `if` clause or statement with negated condition,
    // useful to avoid using _ template just to negate the name
    ifNot(condition, thenBody, elseBody) {
        const cond = new code_1._Code(condition instanceof code_1.Name ? `!${condition}` : `!(${condition})`);
        return this.if(cond, thenBody, elseBody);
    }
    // render `else if` clause - invalid without `if` or after `else` clauses
    elseIf(condition) {
        if (this._lastBlock !== BlockKind.If)
            throw new Error('CodeGen: "else if" without "if"');
        this._out += `}else if(${condition}){` + this._n;
        return this;
    }
    // render `else` clause - only valid after `if` or `else if` clauses
    else() {
        if (this._lastBlock !== BlockKind.If)
            throw new Error('CodeGen: "else" without "if"');
        this._lastBlock = BlockKind.Else;
        this._out += "}else{" + this._n;
        return this;
    }
    // render the closing brace for `if` statement - checks and updates the stack of previous clauses
    endIf() {
        // TODO possibly remove empty branches here
        const b = this._lastBlock;
        if (b !== BlockKind.If && b !== BlockKind.Else)
            throw new Error('CodeGen: "endIf" without "if"');
        this._blocks.pop();
        this._out += "}" + this._n;
        return this;
    }
    // render a generic `for` clause (or statement if `forBody` is passed)
    for(iteration, forBody) {
        this._blocks.push(BlockKind.For);
        this._out += `for(${iteration}){` + this._n;
        if (forBody)
            this.code(forBody).endFor();
        return this;
    }
    // render `for` statement for a range of values
    forRange(nameOrPrefix, from, to, forBody, varKind = exports.varKinds.let) {
        const i = this._scope.toName(nameOrPrefix);
        if (this.opts.es5)
            varKind = exports.varKinds.var;
        return this._loop(code_1._ `for(${varKind} ${i}=${from}; ${i}<${to}; ${i}++){`, i, forBody);
    }
    // render `for-of` statement (in es5 mode a normal for loop)
    forOf(nameOrPrefix, iterable, forBody, varKind = exports.varKinds.const) {
        const name = this._scope.toName(nameOrPrefix);
        if (this.opts.es5) {
            const arr = iterable instanceof code_1.Name ? iterable : this.var("_arr", iterable);
            return this.forRange("_i", 0, new code_1._Code(`${arr}.length`), (i) => {
                this.var(name, new code_1._Code(`${arr}[${i}]`));
                forBody(name);
            });
        }
        return this._loop(code_1._ `for(${varKind} ${name} of ${iterable}){`, name, forBody);
    }
    // render `for-in` statement.
    // With option `forInOwn` (set from Ajv option `ownProperties`) render a `for-of` loop for object keys
    forIn(nameOrPrefix, obj, forBody, varKind = exports.varKinds.const) {
        if (this.opts.forInOwn) {
            return this.forOf(nameOrPrefix, new code_1._Code(`Object.keys(${obj})`), forBody);
        }
        const name = this._scope.toName(nameOrPrefix);
        return this._loop(code_1._ `for(${varKind} ${name} in ${obj}){`, name, forBody);
    }
    _loop(forCode, name, forBody) {
        this._blocks.push(BlockKind.For);
        this._out += `${forCode}${this._n}`;
        forBody(name);
        this.endFor();
        return this;
    }
    // render closing brace for `for` loop - checks and updates the stack of previous clauses
    endFor() {
        const b = this._lastBlock;
        if (b !== BlockKind.For)
            throw new Error('CodeGen: "endFor" without "for"');
        this._blocks.pop();
        this._out += "}" + this._n;
        return this;
    }
    // render `label` clause
    label(label) {
        this._out += `${label}:${this._n}`;
        return this;
    }
    // render `break` statement
    break(label) {
        this._out += (label ? `break ${label};` : "break;") + this._n;
        return this;
    }
    // render `return` statement
    return(value) {
        this._out += "return ";
        this.code(value);
        this._out += ";" + this._n;
        return this;
    }
    // render `try` statement
    try(tryBody, catchCode, finallyCode) {
        if (!catchCode && !finallyCode)
            throw new Error('CodeGen: "try" without "catch" and "finally"');
        this._out += "try{" + this._n;
        this.code(tryBody);
        if (catchCode) {
            const err = this.name("e");
            this._out += `}catch(${err}){` + this._n;
            catchCode(err);
        }
        if (finallyCode) {
            this._out += "}finally{" + this._n;
            this.code(finallyCode);
        }
        this._out += "}" + this._n;
        return this;
    }
    // render `throw` statement
    throw(err) {
        this._out += `throw ${err};` + this._n;
        return this;
    }
    // start self-balancing block
    block(body, expectedToClose) {
        this._blockStarts.push(this._blocks.length);
        if (body)
            this.code(body).endBlock(expectedToClose);
        return this;
    }
    // render braces to balance them until the previous gen.block call
    endBlock(expectedToClose) {
        // TODO maybe close blocks one by one, eliminating empty branches
        const len = this._blockStarts.pop();
        if (len === undefined)
            throw new Error("CodeGen: not in block sequence");
        const toClose = this._blocks.length - len;
        if (toClose < 0 || (expectedToClose !== undefined && toClose !== expectedToClose)) {
            throw new Error("CodeGen: block sequence already ended or incorrect number of blocks");
        }
        this._blocks.length = len;
        if (toClose > 0)
            this._out += "}".repeat(toClose) + this._n;
        return this;
    }
    // render `function` head (or definition if funcBody is passed)
    func(name, args = code_1.nil, async, funcBody) {
        this._blocks.push(BlockKind.Func);
        this._out += `${async ? "async " : ""}function ${name}(${args}){` + this._n;
        if (funcBody)
            this.code(funcBody).endFunc();
        return this;
    }
    // render closing brace for function definition
    endFunc() {
        const b = this._lastBlock;
        if (b !== BlockKind.Func)
            throw new Error('CodeGen: "endFunc" without "func"');
        this._blocks.pop();
        this._out += "}" + this._n;
        return this;
    }
    get _lastBlock() {
        return this._blocks[this._last()];
    }
    set _lastBlock(b) {
        this._blocks[this._last()] = b;
    }
    _last() {
        const len = this._blocks.length;
        if (len === 0)
            throw new Error("CodeGen: not in block");
        return len - 1;
    }
}
exports.CodeGen = CodeGen;
const andCode = mappend(exports.operators.AND);
// boolean AND (&&) expression with the passed arguments
function and(...args) {
    return args.reduce(andCode);
}
exports.and = and;
const orCode = mappend(exports.operators.OR);
// boolean OR (||) expression with the passed arguments
function or(...args) {
    return args.reduce(orCode);
}
exports.or = or;
function mappend(op) {
    return (x, y) => (x === code_1.nil ? y : y === code_1.nil ? x : new code_1._Code(`${x} ${op} ${y}`));
}
//# sourceMappingURL=index.js.map