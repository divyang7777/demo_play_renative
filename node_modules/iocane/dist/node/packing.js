"use strict";
var __spreadArrays = (this && this.__spreadArrays) || function () {
    for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;
    for (var r = Array(s), k = 0, i = 0; i < il; i++)
        for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)
            r[k] = a[j];
    return r;
};
Object.defineProperty(exports, "__esModule", { value: true });
var packing_1 = require("../base/packing");
var packing_2 = require("../base/packing");
exports.packEncryptedText = packing_2.packEncryptedText;
exports.unpackEncryptedText = packing_2.unpackEncryptedText;
var SIZE_ENCODING_BYTES = 4;
function packEncryptedData(encryptedComponents) {
    var signature = Buffer.from(packing_1.getBinarySignature());
    var content = encryptedComponents.content, iv = encryptedComponents.iv, salt = encryptedComponents.salt, auth = encryptedComponents.auth, rounds = encryptedComponents.rounds, method = encryptedComponents.method;
    return Buffer.concat(__spreadArrays([
        signature
    ], [content, iv, salt, auth, rounds, method].reduce(function (buffers, item) {
        var data;
        if (typeof item === "string" || typeof item === "number") {
            data = Buffer.from("" + item, "utf8");
        }
        else if (item instanceof Buffer) {
            data = item;
        }
        else {
            throw new Error("Failed packing data: Invalid component type: " + typeof item);
        }
        buffers.push(sizeToBuffer(data.length));
        buffers.push(data);
        return buffers;
    }, [])));
}
exports.packEncryptedData = packEncryptedData;
function sizeToBuffer(size) {
    var buffer = Buffer.alloc(SIZE_ENCODING_BYTES);
    buffer.writeUInt32BE(size, 0);
    return buffer;
}
function unpackEncryptedData(encryptedContent) {
    var expectedSignature = Buffer.from(packing_1.getBinarySignature());
    var sigLen = expectedSignature.length;
    var signature = encryptedContent.slice(0, sigLen);
    if (!signature.equals(expectedSignature)) {
        throw new Error("Failed unpacking data: Signature mismatch");
    }
    var offset = sigLen;
    var items = [];
    while (offset < encryptedContent.length) {
        var itemSize = encryptedContent.readUInt32BE(offset);
        offset += SIZE_ENCODING_BYTES;
        var item = encryptedContent.slice(offset, offset + itemSize);
        offset += itemSize;
        items.push(item);
    }
    var content = items[0], ivBuff = items[1], saltBuff = items[2], authBuff = items[3], roundsBuff = items[4], methodBuff = items[5];
    return {
        content: content,
        iv: ivBuff.toString("utf8"),
        salt: saltBuff.toString("utf8"),
        auth: authBuff.toString("utf8"),
        rounds: parseInt(roundsBuff.toString("utf8"), 10),
        method: methodBuff.toString("utf8")
    };
}
exports.unpackEncryptedData = unpackEncryptedData;
