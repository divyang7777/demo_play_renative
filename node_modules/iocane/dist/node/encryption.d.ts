/// <reference types="node" />
import { DerivedKeyInfo, EncryptedComponents, EncryptedBinaryComponents } from "../base/constructs";
/**
 * Decrypt text using AES-CBC
 * @param encryptedComponents Encrypted components
 * @param keyDerivationInfo Key derivation information
 * @returns A promise that resolves with the decrypted string
 */
export declare function decryptCBC(encryptedComponents: EncryptedComponents | EncryptedBinaryComponents, keyDerivationInfo: DerivedKeyInfo): Promise<string | Buffer>;
/**
 * Decrypt text using AES-GCM
 * @param encryptedComponents Encrypted components
 * @param keyDerivationInfo Key derivation information
 * @returns A promise that resolves with the decrypted string
 */
export declare function decryptGCM(encryptedComponents: EncryptedComponents | EncryptedBinaryComponents, keyDerivationInfo: DerivedKeyInfo): Promise<string | Buffer>;
/**
 * Encrypt text using AES-CBC
 * @param text The text to encrypt
 * @param keyDerivationInfo Key derivation information
 * @param iv A buffer containing the IV
 * @returns A promise that resolves with encrypted components
 */
export declare function encryptCBC(content: string | Buffer, keyDerivationInfo: DerivedKeyInfo, iv: Buffer): Promise<EncryptedComponents | EncryptedBinaryComponents>;
/**
 * Encrypt text using AES-GCM
 * @param text The text to encrypt
 * @param keyDerivationInfo Key derivation information
 * @param iv A buffer containing the IV
 * @returns A promise that resolves with encrypted components
 */
export declare function encryptGCM(content: string | Buffer, keyDerivationInfo: DerivedKeyInfo, iv: Buffer): Promise<EncryptedComponents | EncryptedBinaryComponents>;
/**
 * IV generator
 * @returns A newly generated IV
 */
export declare function generateIV(): Promise<Buffer>;
/**
 * Generate a random salt
 * @param length The length of the string to generate
 * @returns A promise that resolves with a salt (hex)
 * @throws {Error} Rejects if length is invalid
 */
export declare function generateSalt(length: number): Promise<string>;
